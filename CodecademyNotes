Data modeling as a practice is the process of developing and choosing a way to structure our data and its relationships. A data model is like a blueprint for our data.

Embedded documents
One way to establish a relationship in MongoDB is to use embedded documents. This method allows us to nest data related to a document directly inside of 
it! These nested documents are called sub-documents. We already saw an example of this style when we looked at Model B of the photography database 
(feel free to pause and take a look again). Here is our car and engine example, modeled with an embedded document:

// Car Document
{
  car_id: 48273
  model_name: "Corvette",
  engine: {
    engine_power: 490,
    engine_type: "V8",
    acceleration: "High"
  }
}

In the above example, notice how the engine data is nested inside the car document. This type of data model where we find related data lumped 
together into a single collection is known as a denormalized data model.

Additionally, the following scenarios are good use-cases for embedded documents:

Modeling relationships where one entity contains another, also known as a one-to-one relationship. For example, we can think of a database 
storing data with a relationship between a car and its unique license plate. 
Each record of a car has only one license plate. Modeling relationships that map one entity to many sub-entities, also known as an 
one-to-many relationship. For example, we can think of a database storing data with a relationship between a car owner and their multiple-owned cars. 
Each record of a car owner can own multiple instances of a car.

References
Links between data. Using references, we can split our data into multiple documents and maintain their relationships.

//Car Document
{
  car_id: 48273
  model_name: "Corvette",
  engine_id: 2165
}
 
// Engine Document
{
  id: 2165
  engine_power: 490,
  engine_type: "V8",
  acceleration: "High"
}

This type of data model where we find related data via a link is known as a normalized data model and typically mimics how a 
relational database creates relationships between data.

Additionally, the following scenario is a good use case for references:

Modeling relationships where many instances of one entity can be mapped to many instances of another entity, also 
known as many-to-many relationships. For example, we can think of the relationship between car rentals and individuals 
renting the cars. A car can be rented by multiple individuals, and an individual can rent multiple cars.

Choosing The Right Model
Choosing between references and embedded documents can be tricky. Let’s consider three cases where we have to choose between an 
embedded or a reference-based model. For each case, try to first consider whether we would use references or embedded documents to 
model the relationships between the data.

Case A: A time management application that stores one user per task. We want to store details about the task, such as the task name, 
the task due date, and the user assigned to the task (and their associated details). There can only be one person assigned to each task.
In this case, since we can only have one person assigned to each task, we are modeling a one-to-one relationship. Assuming we will often 
need the data for the user in addition to the task details, it might be preferable to use an embedded document since the information can be 
retrieved together in one query. Here is what our document might look using an embedded document:

{
  task: "Review Rough Outline",
  due: "2022/09/03 09:00",
  assignee: {
    name: "Alex",
    role: "SME",
    contact: "alex@example.com"
  }
}

Case B: A contact information management application that can store multiple addresses per user. The application would store 
important details for the person such as their name, as well as their associated addresses.
In this case, since a single user can have multiple associated addresses, we are modeling a one-to-many relationship. 
There are two distinct ways we can implement the data model.

First, we could use embedded documents. Our documents might look something like this:

{
  first_name: "Alex",
  last_name: "Smith",
  addresses: [
    { label: "home", value: { address: "123 4th Street", city: "Toronto", region: "ON", country: "Canada", postcode: "M1S 2J8" } },
    { label: "work", value: { address: "1633 Broadway 38th floor", city: "New York", region: "NY", country: "USA", postcode: "10019" } },
    "
  ]
}

The embedded documents model above would be preferable if we are making many queries on the addresses field since we would only 
need to query a single document to receive our results.

where we notice that embedded documents are starting to repeat, we may consider using references instead. By using references, our 
collection could look like this instead:

// Addresses Collection
{
  _id: 123456789
  address: {     
    street: "123 4th Street", 
    city: "Toronto", 
    region: "ON", 
    country: "Canada", 
    postcode: "M1S 2J8" 
  }
},
{ 
  _id: 9292944,
  address: { 
    street: "1633 Broadway 38th floor",
    city: "New York", 
    region: "NY", 
    country: "USA", 
    postcode: "10019" 
  } 
}

// User Collection 
{
  first_name: "Alex",
  last_name: "Smith"
  addresses: [ 123456789, 9292944 ] 
},
{
  first_name: "Josh",
  last_name: "Gold",
  addresses: [ 123456789 ] 
},
{
  first_name: "Timbo",
  last_name: "Gray",
  addresses: [ 123456789 ]
}

Notice how the user documents include an array field named addresses that stores the unique id of the address document thus avoiding the 
repetition of each individual address. While the above example shows one case where we might use references, its important to note that 
we need to consider how frequently we are accessing the address information and how large it is before making a data modeling decision.

Case C: A school registration application that manages multiple students. Each student can be in multiple classes. Each class record 
can easily identify which students are registered and each student record can quickly find any associated classes.
In this application, we have many students sharing a relationship with many classes. Here, we need to model a many-to-many relationship. 
In this case, references might be preferred. Our collections would look similar to this:

// Students Collection
 
 
{     
  _id: 1, 
  name: "Alex",
  average_grade: 3.9, 
  course_ids: [ 1, 2, 4 ] 
},
{
  _id: 2, 
  name: "Bob", 
  average_grade: 2.4, 
  course_ids: [ 3, 4 ] 
}

// Classes Collection
{ 
  _id: 1, 
  name: "Intro to MongoDB", 
  student_ids: [ 1 ] 
},
{     
  _id: 2, 
  name: "Programming 101", 
  student_ids: [ 1 ]
 },
{     
  _id: 3, 
  name: "Networking Concepts", 
  student_ids: [ 2 ]
 },
{     
  _id: 4, 
  name: "Understanding Distributed Systems", 
  student_ids: [ 1, 2 ] 
}

BROWSING AND SELECTING COLLECTIONS

command: show dbs
Will output a list of all the databases in our current instance and the disk space each takes up

command: use <db>
example: use online_plant_shop
This would place us inside of the database we have chosen. If the database we specify does not exist MongoDB will create it and place us inside
of it.

command: db
Will output the name of the database we are currently in

QUERYING
Persistence refers to a database's ability to store data that is stable and enduring. Four essential functions that a persistent database must be able to
perform:
1.) create new data entries
2.) read data entries
3.) update data entries
4.) delete data entries

Querying is the process by which we request data from the database. The most common way to query data in MongoDB is to use the .find() method

.find()
SYNTAX: db.<collection>.find()

MongoDB will return up to the first set of matching documents. If we want to see the next batch of documents, we use the it keyword, short for iterate
command: it

QUERYING COLLECTIONS
If we are looking for a specific document or set of documents we can pass a query to the .find() method as its first argument inside of the 
parenthesis. With the query argument, we can list selection criteria and only return documents in the collection that match those specifications

The query argument is formatted as a document with field-value pairs that we want to match

Example syntax:
db.<collection>.find(
  {
    <field>: <value>,
    <second_field>: <value>
    ...
  }
);

{
  maker: "Honda",
  country: "Japan",
  models: [
    { name: "Accord" },
    { name: "Civic" },
    { name: "Pilot },
    …
  ]
},
 
{
  maker: "Toyota",
  country: "Japan",
  models: [
    { name: "4Runner" },
    { name: "Corolla" },
    { name: "Rav4" },
    …
  ]
},
{
  maker: "Ford",
  country: "USA",
  models: [
    { name: "F-150" },
    { name: "Bronco"},
    { name: "Escape"},
    …
  ]
}

Imagine we wanted to query this collection to find all of the vehicles that are manufactured in "Japan". 
We could use the .find() command with a query, like so:

db.auto_makers.find({ country: "Japan" });

This would output the following documents from our collection:

{
  maker: "Honda",
  country: "Japan",
  models: [
    { name: "Accord" },
    { name: "Civic" },
    { name: "Pilot },
    …
  ]
},
{
  maker: "Toyota",
  country: "Japan",
  models: [
    { name: "4Runner" },
    { name: "Corolla" },
    { name: "Rav4" },
    …
  ]
}

Note: Query fields and their associated values are case and space sensitive. 
So, a query for a value "Corolla" would not be valid for a lowercase version like "corolla". 
This also applies if we accidentally included spaces. So, " corolla" would also not be valid if the value was "corolla". 
